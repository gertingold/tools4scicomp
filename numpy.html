<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>4. Scientific computing with NumPy and SciPy &#8212; Tools for Scientific Computing 0.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=fce32b03" />
    <script src="_static/documentation_options.js?v=b489f392"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Run-time analysis" href="profiling.html" />
    <link rel="prev" title="3. Testing of code" href="testing.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tools for Scientific Computing 0.3 documentation</span></a></h1>
        <h2 class="heading"><span>4. Scientific computing with NumPy and SciPy</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="testing.html"><span class="section-number">3. </span>Testing of code</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="profiling.html"><span class="section-number">5. </span>Run-time analysis</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="scientific-computing-with-numpy-and-scipy">
<span id="scientific-libraries"></span><h1><span class="section-number">4. </span>Scientific computing with NumPy and SciPy<a class="headerlink" href="#scientific-computing-with-numpy-and-scipy" title="Link to this heading">¶</a></h1>
<section id="python-scientific-ecosystem">
<h2><span class="section-number">4.1. </span>Python scientific ecosystem<a class="headerlink" href="#python-scientific-ecosystem" title="Link to this heading">¶</a></h2>
<p>Python comes with a rich variety of freely available third-party packages
including quite a number of packages which are routinely used in scientific
computing. Before developing code for a standard problem like an eigenvalue
analysis or numerical quadrature to name just two examples, it is recommended
to first check the functionality provided by the existing libraries. It is
very likely that such libraries are more reliable and more efficient than
self-developed code. This does not mean though that such libraries are guaranteed
to be error-free and there may exist reasons to develop even basic numerical
code oneself.</p>
<p>NumPy <a class="footnote-reference brackets" href="#id13" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> constitutes the basis of the Python scientific ecosystem. The
multi-dimensional array datatype defined in NumPy is pivotal for a huge number
of scientific applications and is made use of in many ways in the other two
core packages SciPy and matplotlib. SciPy provides submodules in many areas
relevant for scientific applications like optimization, signal processing,
linear algebra, statistics, special functions and several more <a class="footnote-reference brackets" href="#id14" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. Part
of the code is written in C or Fortran resulting in fast execution speed.
Matplotlib offers comprehensive support for graphical presentation of data
<a class="footnote-reference brackets" href="#matplotlib" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
<p>In recent year, the Jupyter notebook, formerly known as IPython notebook, has
become very popular, in particular among the data scientists <a class="footnote-reference brackets" href="#jupyter" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>. The
notebook can be used with Python and a number of other programming languages
like Julia and R and allows to integrate code, text as well as images and
other media in a single file.</p>
<p>In addition, there are a number of more dedicated packages of which we will
name a few. The Python data analysis library pandas <a class="footnote-reference brackets" href="#pandas" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> offers high-performance,
easy-to-use data structures and data analysis tools. Symbolic computation is
possible in Python with the help of the sympy package <a class="footnote-reference brackets" href="#sympy" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>. Image-processing
routines can be found in scikit-image <a class="footnote-reference brackets" href="#skimage" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>. Among the many features of this
package, we mention image segmentation which can for example be used to analyse
electron microscope images of heterogeneous surfaces. Machine learning has recently
developed into a very active field which receives excellent support in Python
through the scikit-learn package <a class="footnote-reference brackets" href="#sklearn" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>.</p>
<p>We emphasize that the list of packages briefly described here, is not exhaustive
and there exist more interesting Python packages useful in scientific applications.
A recommended source of information on the Python scientific ecosystem are the
<a class="reference external" href="https://www.scipy-lectures.org/">SciPy lecture notes</a>.</p>
</section>
<section id="numpy">
<h2><span class="section-number">4.2. </span>NumPy<a class="headerlink" href="#numpy" title="Link to this heading">¶</a></h2>
<section id="python-lists-and-matrices">
<h3><span class="section-number">4.2.1. </span>Python lists and matrices<a class="headerlink" href="#python-lists-and-matrices" title="Link to this heading">¶</a></h3>
<p>It is rather typical in scientific applications to deal with homogeneous data,
i.e. data of the same datatype, organized in arrays. An obvious example for
one-dimensional arrays are vectors in their coordinate representation and
matrices would naturally be stored in two-dimensional arrays. There also exist
applications for even higher-dimensional arrays. The data representing a
digital colour image composed of <span class="math notranslate nohighlight">\(N\times M\)</span> pixels can be stored in an
<span class="math notranslate nohighlight">\(N\times M\times 3\)</span> array with three planes representing the three colour
channels red, green, and blue as visualized in <a class="reference internal" href="#rgbarray"><span class="std std-numref">Figure 4.1</span></a>.</p>
<figure class="align-center" id="id15">
<span id="rgbarray"></span><a class="reference internal image-reference" href="_images/rgbarray.png"><img alt="_images/rgbarray.png" src="_images/rgbarray.png" style="width: 15em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.1 </span><span class="caption-text">The data of a digital colour image composed of <span class="math notranslate nohighlight">\(N\times M\)</span> pixels can be
represented as a <span class="math notranslate nohighlight">\(N\times M\times 3\)</span> array where the three planes correspond
to the red, green, and blue channels.</span><a class="headerlink" href="#id15" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The first question to address is how one can store such data structures in Python and
how can one make sure that the data can be processed fast. Among the standard datatypes
available in Python, a natural candidate would be lists. In Python, lists are very
flexible objects which allow to store element of all kinds of datatypes including lists.
While this offers us in principle the possibility to represent multi-dimensional data,
the flexibility comes with a significant computational overhead. As we will see later,
homogeneous data can be handled more efficiently. Leaving the question of efficiency
aside for a moment, we can ask whether list are suited at all to represent matrices.</p>
<p>Let us consider a two-dimensional matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathsf{M} = \begin{pmatrix} 1.1 &amp; 2.2 &amp; 3.3\\ 4.4 &amp; 5.5 &amp; 6.6\\ 7.7 &amp; 8.8 &amp; 9.9\end{pmatrix}\,.\end{split}\]</div>
<p>It seems natural to store these data in a list of lists</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.4</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">,</span> <span class="mf">6.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.7</span><span class="p">,</span> <span class="mf">8.8</span><span class="p">,</span> <span class="mf">9.9</span><span class="p">]]</span>
</pre></div>
</div>
<p>of which a single element can be accessed by first selecting the appropriate row and then
the desired entry</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1.1, 2.2, 3.3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="go">3.3</span>
</pre></div>
</div>
<p>The only difference with respect to the common mathematical notation is that the indices start
at 0 and not at 1. In order to access a single row in a way which makes the two-dimensional
character of the matrix more transparent, we could use</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
<span class="go">[1.1, 2.2, 3.3]</span>
</pre></div>
</div>
<p>But does this also work for a column? Let us give it a try.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="p">[:][</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1.1, 2.2, 3.3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="p">[:]</span>
<span class="go">[[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]]</span>
</pre></div>
</div>
<p>The result is rather disappointing because interchanging the two slices yields again the
first row. The reason can be seen from the lower two lines. In the first step, we obtain
again the full list and in the second step we access its first element, i.e. the first
row, not the first column. Even though there are ways to extract a column from a list of
lists, e.g. by means of a list comprehension, there is now consistent approach to extracting
rows and columns from a list of lists. Our construction is certainly not a good one and
we are in need of a new datatype.</p>
</section>
<section id="numpy-arrays">
<h3><span class="section-number">4.2.2. </span>NumPy arrays<a class="headerlink" href="#numpy-arrays" title="Link to this heading">¶</a></h3>
<p>The new datatype provided by NumPy is a multidimensional homogeneous array of fixed-size
items called <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>. Before starting to explore this datatype, we need to import
the NumPy package. While there are different ways to do so, there is one recommended way.
Let us take a look at the various alternatives:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>                <span class="c1"># don&#39;t do this!</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>  <span class="c1"># not recommended</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>                       <span class="c1"># ok, but the following line is better</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>                 <span class="c1"># recommended way</span>
</pre></div>
</div>
<p>Importing the complete namespace of NumPy as done in the first line is no good idea because
the namespace is rather large. Therefore, there is a danger of name conflicts and loss of
control. As an alternative, one could restrict the import to the functions actually needed
as shown in the second line. However, as can be seen in our example, there exist functions
like sine (<code class="docutils literal notranslate"><span class="pre">sin</span></code>) and cosine (<code class="docutils literal notranslate"><span class="pre">cos</span></code>) in NumPy. In the body of the code it might not always
be evident whether these functions are taken from NumPy or rather the <code class="docutils literal notranslate"><span class="pre">math</span></code> or <code class="docutils literal notranslate"><span class="pre">cmath</span></code>
module. It is better to more explicit. The import given in the third line is acceptable but
it requires to put <code class="docutils literal notranslate"><span class="pre">numpy.</span></code> in front of each object taken from the NumPy namespace.
The usual way to import NumPy is given in the fourth line. Virtually every user seeing <code class="docutils literal notranslate"><span class="pre">np.</span></code>
in the code will assume that the corresponding object belongs to NumPy. It is always a
good idea to stick to such conventions to render the code easily understandable.</p>
<p>As the next step, we need to create an array and fill it with data. Whenever we
are simply referring to an array, we actually mean an object of datatype
<code class="docutils literal notranslate"><span class="pre">ndarray</span></code>. Given certain similarities with Python lists, it is tempting to
use the <code class="docutils literal notranslate"><span class="pre">append</span></code> method for that purpose as one often does with lists. In
fact, NumPy provides an <code class="docutils literal notranslate"><span class="pre">append</span></code> method. However, because Python lists and
NumPy arrays are conceptually quite different, there exist good reasons for
avoiding this method if at all possible.</p>
<p>The objects contained in a Python list are typically scattered in memory and the
position of each chunk of data is stored in a list of pointers. In contrast, the
data of a NumPy array are stored in one contiguous piece of memory. As we will
see later, this way of storing an array allows to determine by means of a simple
calculation where a certain element can be found. Accessing elements therefore is
very efficient.</p>
<p>When appending data to an array, there will generally be no place for the data
in memory to guarantee the array to remain contiguous. Appending data in NumPy
thus implies the creation of an entirely new array. As a consequence, the data
constituting the original array have to be moved to a new place in memory. The
time required for this process can become significant for larger arrays and
ultimately is limited by the hardware. Using the <code class="docutils literal notranslate"><span class="pre">append</span></code> method can thus
become a serious performance problem.</p>
<p>Generally, when working with NumPy arrays, it is a good idea to avoid the creation
of new arrays as much as possible as this may drastically degrade performance.
In particular, one should not count on changing the size of an array during the
calculation. Already for the creation of the array one should decide how large
it will need to be.</p>
<p>One way to find out how a NumPy array can be created it to search the NumPy documentation.
This can be done even within Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lookfor</span><span class="p">(</span><span class="s1">&#39;create array&#39;</span><span class="p">)</span>
<span class="go">Search results for &#39;create array&#39;</span>
<span class="go">---------------------------------</span>
<span class="go">numpy.array</span>
<span class="go">    Create an array.</span>
<span class="go">numpy.memmap</span>
<span class="go">    Create a memory-map to an array stored in a *binary* file on disk.</span>
<span class="go">numpy.diagflat</span>
<span class="go">    Create a two-dimensional array with the flattened input as a diagonal.</span>
<span class="go">numpy.fromiter</span>
<span class="go">    Create a new 1-dimensional array from an iterable object.</span>
<span class="go">numpy.partition</span>
<span class="go">    Return a partitioned copy of an array.</span>
</pre></div>
</div>
<p>Here, we have only have reproduced a small part of the output. Furthermore, here and
in the following, we assume that NumPy has been imported in the way recommended above
so that its namespace can be accessed via the abbreviation <code class="docutils literal notranslate"><span class="pre">np</span></code>.</p>
<p>Already the first entry in the list of proposed methods is the one to use in our
present situation. More information can be obtained as usual by means of <code class="docutils literal notranslate"><span class="pre">help(np.array)</span></code>
or alternatively by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="go">array(object, dtype=None, copy=True, order=&#39;K&#39;, subok=False, ndmin=0)</span>

<span class="go">Create an array.</span>

<span class="go">Parameters</span>
<span class="go">----------</span>
<span class="go">object : array_like</span>
<span class="go">    An array, any object exposing the array interface, an object whose</span>
<span class="go">    __array__ method returns an array, or any (nested) sequence.</span>
<span class="go">dtype : data-type, optional</span>
<span class="go">    The desired data-type for the array.  If not given, then the type will</span>
<span class="go">    be determined as the minimum type required to hold the objects in the</span>
<span class="go">    sequence.  This argument can only be used to &#39;upcast&#39; the array.  For</span>
<span class="go">    downcasting, use the .astype(t) method.</span>
</pre></div>
</div>
<p>Again, only the first part of the output has been reproduced. It is recommended
though to take a look at the rest of the help text as it provides a nice example
how doctests can be used both for documentation purposes and for testing.</p>
<p>As can be seen from the help text, we need at least one argument <code class="docutils literal notranslate"><span class="pre">object</span></code> which
should be an object with an <code class="docutils literal notranslate"><span class="pre">__array__</span></code> method or a possibly nested sequence.
Let us consider a first example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>          <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>          <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myarray</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">myarray</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.ndarray&#39;&gt;</span>
</pre></div>
</div>
<p>We have started with a list of lists which is a valid argument for <code class="docutils literal notranslate"><span class="pre">np.array</span></code>.
Printing out the result indicates indeed that we have obtained a NumPy array.
A confirmation is obtained by asking for the type of <code class="docutils literal notranslate"><span class="pre">myarray</span></code>.</p>
<p>The data of an array are stored contiguously in memory but what does that really
mean for the two-dimensional array which we have just created? Natural ways would
be store the date columnwise or rowwise. The first variant is realized in the
programming language C while the second variant is used by Fortran. Apart from
the actual data, an array obviously needs a number of metadata in order to know
how to interpret the content of the memory space attributed to the area. These
metadata are a powerful concept because they make it possible to change the
interpretation of the data without copying them, thereby contributing to the
efficiency of NumPy arrays.</p>
<p>It is useful to get some basic insight into how a NumPy array works. In order
to analyze the metadata, we use a short function enabling us to list the
attributes of an array.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">array_attributes</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;itemsize&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;strides&#39;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">:</span><span class="s1">8s</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">attr</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A convenient way of generating an array for test purposes is the <code class="docutils literal notranslate"><span class="pre">arange</span></code> function
which works very much like the standard <code class="docutils literal notranslate"><span class="pre">range</span></code> iterator as far as its basic
arguments <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code>, and <code class="docutils literal notranslate"><span class="pre">step</span></code> are concerned. In this way, we can
easily construct a one-dimensional array with integer entries from 0 to 15 and
inspect its properties:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span>
<span class="go">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array_attributes</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="go">ndim    : 1</span>
<span class="go">size    : 16</span>
<span class="go">itemsize: 8</span>
<span class="go">dtype   : int64</span>
<span class="go">shape   : (16,)</span>
<span class="go">strides : (8,)</span>
</pre></div>
</div>
<p>Let us take a look at the different attributes. The attribute <code class="docutils literal notranslate"><span class="pre">ndim</span></code> indicates
the number of dimension of the array which in our example is one-dimensional and
therefore <code class="docutils literal notranslate"><span class="pre">ndim</span></code> equals 1. The <code class="docutils literal notranslate"><span class="pre">size</span></code> of 16 means that the array contains a
total of 16 items. Each item has an <code class="docutils literal notranslate"><span class="pre">itemsize</span></code> of 8 bytes or 64 bits, resulting
in a total size of 128 bytes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">128</span>
</pre></div>
</div>
<p>The attribute <code class="docutils literal notranslate"><span class="pre">dtype</span></code> represents the datatype which in our example is <code class="docutils literal notranslate"><span class="pre">int64</span></code>,
i.e. an integer type of a length of 64 bits. Quite in contrast to the usual integer
type in Python which can in principle handle integers of arbitrary size, the integer
values in our array are clearly limited. An example using integers of only 8 bits
length can serve to illustrate the problem of overflows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="go">array([   1,   11,   21,   31,   41,   51,   61,   71,   81,   91,  101,</span>
<span class="go">        111,  121, -125, -115, -105], dtype=int8)</span>
</pre></div>
</div>
<p>Take a look at the items in this array and try to understand what is going on.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">numerictypes</span><span class="o">.</span><span class="n">sctypes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    </span><span class="si">{</span><span class="n">elem</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">int</span>
<span class="go">    &lt;class &#39;numpy.int8&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.int16&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.int32&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.int64&#39;&gt;</span>
<span class="go">uint</span>
<span class="go">    &lt;class &#39;numpy.uint8&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.uint16&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.uint32&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.uint64&#39;&gt;</span>
<span class="go">float</span>
<span class="go">    &lt;class &#39;numpy.float16&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.float32&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.float64&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.float128&#39;&gt;</span>
<span class="go">complex</span>
<span class="go">    &lt;class &#39;numpy.complex64&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.complex128&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.complex256&#39;&gt;</span>
<span class="go">others</span>
<span class="go">    &lt;class &#39;bool&#39;&gt;</span>
<span class="go">    &lt;class &#39;object&#39;&gt;</span>
<span class="go">    &lt;class &#39;bytes&#39;&gt;</span>
<span class="go">    &lt;class &#39;str&#39;&gt;</span>
<span class="go">    &lt;class &#39;numpy.void&#39;&gt;</span>
</pre></div>
</div>
<p>The first four groups of datatypes include integers, unsigned integers, floats and
complex numbers of different sizes. Among the other types, booleans as well as strings
are of some interest. Note, however, that the data in an array always should be homogeneous.
If different datatypes are mixed in the assignment to an array, it may happen that a datatype
is cast to a more flexible one. For strings, the size of each entry will be determined by
the longest string.</p>
<p>Probably the most interesting attributes of an array are <code class="docutils literal notranslate"><span class="pre">shape</span></code> and <code class="docutils literal notranslate"><span class="pre">strides</span></code> because
the allow us to reinterpret the data of the original one-dimensional array in different
ways without the need to copy from memory to memory. Let us first try to understand the meaning
of the tuples <code class="docutils literal notranslate"><span class="pre">(16,)</span></code> for <code class="docutils literal notranslate"><span class="pre">shape</span></code> and <code class="docutils literal notranslate"><span class="pre">(8,)</span></code> for <code class="docutils literal notranslate"><span class="pre">strides</span></code>. Both tuples have the same
size which equals one because the considered array is one-dimensional. Therefore, <code class="docutils literal notranslate"><span class="pre">shape</span></code> does
not contain any new information. It simply reflects the size of the array as does the attribute
<code class="docutils literal notranslate"><span class="pre">size</span></code>. The value of <code class="docutils literal notranslate"><span class="pre">strides</span></code> means that in order to move from the beginning of an item
in memory to the beginning of the next one, one needs to more eight bytes. This information
is consistent with the <code class="docutils literal notranslate"><span class="pre">itemsize</span></code>. What seems like redundant information becomes more
interesting when we go from a one-dimensional array to a multi-dimensional array. For simplicity
we convert the our one-dimensional array <code class="docutils literal notranslate"><span class="pre">matrix</span></code> into a two-dimensional square array.
To this purpose we make use of the <code class="docutils literal notranslate"><span class="pre">reshape</span></code> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array_attributes</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="go">ndim    : 2</span>
<span class="go">size    : 16</span>
<span class="go">itemsize: 8</span>
<span class="go">dtype   : int64</span>
<span class="go">shape   : (4, 4)</span>
<span class="go">strides : (32, 8)</span>
</pre></div>
</div>
<p>In the first line, we bring our one-dimensional array with 16 elements into a
<span class="math notranslate nohighlight">\(4\times4\)</span> array.  Three attributes change their value in this process.
<code class="docutils literal notranslate"><span class="pre">ndim</span></code> is now 2 because we created a two-dimensional array. The <code class="docutils literal notranslate"><span class="pre">shape</span></code> attribute
with value <code class="docutils literal notranslate"><span class="pre">(4,</span> <span class="pre">4)</span></code> reflects the fact that now we have 4 rows and 4 columns.
Finally, the <code class="docutils literal notranslate"><span class="pre">strides</span></code> are given by the tuple <code class="docutils literal notranslate"><span class="pre">(32,</span> <span class="pre">8)</span></code>. To go in memory from
an item to the item in the next column and in the same row means that we should move
by 8 bytes. The two items are neighbors in memory. However, if we stay within the
same column and want to move to the next row, we have to jump by 32 bytes in memory.</p>
<p>To further illustrate the meaning of <code class="docutils literal notranslate"><span class="pre">shape</span></code> and <code class="docutils literal notranslate"><span class="pre">strides</span></code> we consider a second
example. A linear arrangement of six data in memory can be interpreted in three
different ways as depicted in <a class="reference internal" href="#strides"><span class="std std-numref">Figure 4.2</span></a>. In the uppermost example, <code class="docutils literal notranslate"><span class="pre">strides</span></code>
is set to <code class="docutils literal notranslate"><span class="pre">(8,)</span></code>. The tuple <code class="docutils literal notranslate"><span class="pre">strides</span></code> tuple contains only one element and we
are therefore dealing with a one-dimensional array. Assuming the datasize to be 8,
the array consists of all six data elements. In the second case, <code class="docutils literal notranslate"><span class="pre">strides</span></code> are
set to <code class="docutils literal notranslate"><span class="pre">(24,</span> <span class="pre">8)</span></code>. Accordingly, the matrix consists of two rows and three columns.
Finally, in the bottom example with <code class="docutils literal notranslate"><span class="pre">strides</span></code> equal to <code class="docutils literal notranslate"><span class="pre">(16,</span> <span class="pre">8)</span></code>, the data
are interpreted as a matrix consisting of two columns and three rows. Note that
no rearrangement of data in memory is required in order to go from one matrix
to another one. Only the way, how the position of a certain element in memory
is obtained, changes when <code class="docutils literal notranslate"><span class="pre">strides</span></code> is modified.</p>
<figure class="align-center" id="id16">
<span id="strides"></span><a class="reference internal image-reference" href="_images/strides.png"><img alt="_images/strides.png" src="_images/strides.png" style="width: 30em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.2 </span><span class="caption-text">Linear data in memory can be interpreted in different ways by appropriately
choosing the <code class="docutils literal notranslate"><span class="pre">strides</span></code> tuple.</span><a class="headerlink" href="#id16" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>A two-dimensional matrix can easily be transposed. Behind the scenes the values
in the <code class="docutils literal notranslate"><span class="pre">strides</span></code> tuple are interchanged:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(24, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([[0, 3, 6],</span>
<span class="go">       [1, 4, 7],</span>
<span class="go">       [2, 5, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(8, 24)</span>
</pre></div>
</div>
<p>Strides are a powerful concept. However, one should be careful not to violate
the boundaries of the data because otherwise memory might be interpreted in a
meaningless way. In the following two examples, the first demonstrates an
interesting way to create a special pattern of data. The second example, where
one of the strides is only half of the datasize, shows how useless results
can be produced:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2, 3],</span>
<span class="go">       [1, 2, 3, 4],</span>
<span class="go">       [2, 3, 4, 5],</span>
<span class="go">       [3, 4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[          0,  4294967296,           1,  8589934592],</span>
<span class="go">       [          1,  8589934592,           2, 12884901888],</span>
<span class="go">       [          2, 12884901888,           3, 17179869184],</span>
<span class="go">       [          3, 17179869184,           4, 21474836480]])</span>
</pre></div>
</div>
<p>In the end, the user manipulating <code class="docutils literal notranslate"><span class="pre">strides</span></code> is responsible for all consequences
which his or her action may have.</p>
</section>
<section id="creating-arrays">
<span id="id9"></span><h3><span class="section-number">4.2.3. </span>Creating arrays<a class="headerlink" href="#creating-arrays" title="Link to this heading">¶</a></h3>
<p>We have seen in the previous section that an array can be created by providing <code class="docutils literal notranslate"><span class="pre">np.array</span></code>
with an object possessing an <code class="docutils literal notranslate"><span class="pre">__array__</span></code> method or a nested sequence. However, this
requires to create the object or nested sequence in the first place. Often, more convenient
methods exist. As we have pointed out earlier, when creating an array, one should have an
idea of the desired size and usually also of the datatype to be stored in the array. Given
this information, there exists a variety of methods to create an array depending on the
specific needs.</p>
<p>It is not unusual to start with an array filled with zeros. Let us create a <span class="math notranslate nohighlight">\(2\times2\)</span> array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0., 0.],</span>
<span class="go">       [0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<p>As we can see, the default type is <code class="docutils literal notranslate"><span class="pre">float64</span></code>. If we prefer an array of integers, we could specify
the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;int64&#39;)</span>
</pre></div>
</div>
<p>As an alternative, one can create an empty array which should however not be confused with an array
filled with zeros. An empty array will just claim the necessary amount of memory without doing anything
to the data present in that piece of memory. This is fine if one is going to specify the content of all
array data subsequently before using the array. Otherwise, one will deal with random data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[6.94870988e-310, 6.94870988e-310, 7.89614591e+150],</span>
<span class="go">       [1.37038197e-013, 2.08399685e+064, 3.51988759e+016],</span>
<span class="go">       [8.23900250e+015, 7.32845376e+025, 1.71130458e+059]])</span>
</pre></div>
</div>
<p>An alternative to filling an array with zeros could be to fill it with ones or another value which
can be obtained by multiplication:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[1., 1.],</span>
<span class="go">       [1., 1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[10., 10.],</span>
<span class="go">       [10., 10.]])</span>
</pre></div>
</div>
<p>As one can see in this example, the multiplication by a number acts on all
elements of the array.  This behavior is probably what one would expect at this
point. As we will see in <a class="reference internal" href="#broadcasting"><span class="std std-numref">Section 4.2.5</span></a>, we are here making use of a
more general concept referred to as broadcasting.</p>
<p>Often, one needs arrays with more structure than the one we have created so far. It is not uncommon,
that the diagonal entries take a special form. An identity matrix can easily be created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([[1., 0., 0.],</span>
<span class="go">       [0., 1., 0.],</span>
<span class="go">       [0., 0., 1.]])</span>
</pre></div>
</div>
<p>The result will always be a square matrix. A more general method to fill the diagonal or a shifted
diagonal is provided by <code class="docutils literal notranslate"><span class="pre">np.eye</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">array([[1., 0., 0., 0.],</span>
<span class="go">       [0., 1., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0., 1., 0., 0.],</span>
<span class="go">       [0., 0., 1., 0.],</span>
<span class="go">       [0., 0., 0., 1.],</span>
<span class="go">       [0., 0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 2., -1.,  0.,  0.],</span>
<span class="go">       [-1.,  2., -1.,  0.],</span>
<span class="go">       [ 0., -1.,  2., -1.],</span>
<span class="go">       [ 0.,  0., -1.,  2.]])</span>
</pre></div>
</div>
<p>These examples show that <code class="docutils literal notranslate"><span class="pre">np.eye</span></code> does not expect a tuple specifying the shape. Instead, the
first two arguments give the number of rows and columns. If the second argument is absent,
the resulting matrix is a square matrix. In the second and third example, the missing second
argument is the reason why we have to specify that the second argument is intended as the
shift <code class="docutils literal notranslate"><span class="pre">k</span></code> of the diagonal. The third example gives an idea of how the Hamiltonian for the
kinetic energy in a tight-binding model can be constructed.</p>
<p>It is also possible to generate diagonals or, by specifying <code class="docutils literal notranslate"><span class="pre">k</span></code>, shifted diagonals with
different values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">array([[1, 0, 0, 0],</span>
<span class="go">       [0, 2, 0, 0],</span>
<span class="go">       [0, 0, 3, 0],</span>
<span class="go">       [0, 0, 0, 4]])</span>
</pre></div>
</div>
<p>Using a two-dimensional array as argument, its diagonal elements can be extracted by means
of the same function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="go">array([ 0,  5, 10, 15])</span>
</pre></div>
</div>
<p>If the elements of an array can be expressed as a function of the indices, <code class="docutils literal notranslate"><span class="pre">fromfunction</span></code>
can be used to generate the elements. As a simple example, we create a multiplication table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[ 1,  2,  3,  4,  5,  6],</span>
<span class="go">       [ 2,  4,  6,  8, 10, 12],</span>
<span class="go">       [ 3,  6,  9, 12, 15, 18],</span>
<span class="go">       [ 4,  8, 12, 16, 20, 24],</span>
<span class="go">       [ 5, 10, 15, 20, 25, 30],</span>
<span class="go">       [ 6, 12, 18, 24, 30, 36]])</span>
</pre></div>
</div>
<p>Even though we present a two-dimensional example, the latter approach can be used
to create arrays of an arbitrary dimension.</p>
<p>The function used in the previous example was a very simple one. Occasionally, one might
need more complicated functions like one of the trigonometric functions. In fact, NumPy
provides a number of so-called universal functions which we will discuss in <a class="reference internal" href="#ufuncs"><span class="std std-numref">Section 4.2.6</span></a>.
Such functions accept an array as argument and return an array. Here, we will concentrate
on creating arguments for universal functions.</p>
<p>A first function is <code class="docutils literal notranslate"><span class="pre">arange</span></code> which we have used before for integers. It is a generalization
of the standard <code class="docutils literal notranslate"><span class="pre">range</span></code> which works even for floats:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="go">array([1. , 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9])</span>
</pre></div>
</div>
<p>As with <code class="docutils literal notranslate"><span class="pre">range</span></code>, the first argument is the start value while the second argument refers
to the final value which is not included. Because of rounding errors, the last statement
is not always true. Finally, the third argument is the stepwidth. An alternative is offered
by the <code class="docutils literal notranslate"><span class="pre">linspace</span></code> function which by default will make sure that the start value and the
final value are part of the array. Instead of the stepwidth, the number of points is specified:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="go">array([1. , 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. ])</span>
</pre></div>
</div>
<p>A common mistake is to assume that the last argument gives the number of intervals which,
however, is not the case. Thus, there is some danger that one is off by one in the last
argument. Sometimes it is useful to ask for the stepwidth:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([1. , 1.5, 2. , 2.5, 3. , 3.5, 4. ]), 0.5)</span>
</pre></div>
</div>
<p>Here, the stepwidth does not need to be determined by hand.</p>
<p>Occasionally, a logarithmic scale can be useful. In this case, the start value and the final
value refer to the exponent. The base by default is ten but can be modified, if necessary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">array([   1.,   10.,  100., 1000.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([1.        , 1.41421356, 2.        , 2.82842712, 4.        ])</span>
</pre></div>
</div>
<p>The following example illustrate the application of <code class="docutils literal notranslate"><span class="pre">linspace</span></code> in a universal function
to produce a graphical representation of the function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x7f22d619cc88&gt;]</span>
</pre></div>
</div>
<p>The generated graph is reproduced in <a class="reference internal" href="#mpl-numpy-1"><span class="std std-numref">Figure 4.3</span></a>.</p>
<figure class="align-center" id="id17">
<span id="mpl-numpy-1"></span><a class="reference internal image-reference" href="_images/mpl_numpy_1.png"><img alt="_images/mpl_numpy_1.png" src="_images/mpl_numpy_1.png" style="width: 20em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.3 </span><span class="caption-text">Simple example of a function graph generated by operating with a universal function
on an array generated by <code class="docutils literal notranslate"><span class="pre">linspace</span></code>.</span><a class="headerlink" href="#id17" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Arrays can also be filled with data taken from a file. This can for example be the case
if data obtained from a measurement are first stored in a file before being processed
or if numerical data are stored before a graphical representation is produced. Assume
that we have a data file called <code class="docutils literal notranslate"><span class="pre">mydata.dat</span></code> with the following content:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># time position</span>
   <span class="mf">0.0</span>   <span class="mf">0.0</span>
   <span class="mf">0.1</span>   <span class="mf">0.1</span>
   <span class="mf">0.2</span>   <span class="mf">0.4</span>
   <span class="mf">0.3</span>   <span class="mf">0.9</span>
</pre></div>
</div>
<p>Loading the data from the file, we obtain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;mydata.dat&#39;</span><span class="p">)</span>
<span class="go">array([[0. , 0. ],</span>
<span class="go">       [0.1, 0.1],</span>
<span class="go">       [0.2, 0.4],</span>
<span class="go">       [0.3, 0.9]])</span>
</pre></div>
</div>
<p>By default, lines starting with <code class="docutils literal notranslate"><span class="pre">#</span></code> will be considered as comments and are ignored.
The function <code class="docutils literal notranslate"><span class="pre">loadtxt</span></code> offers a number of arguments to load data in a rather flexible
way. Even more possibilities are offered by <code class="docutils literal notranslate"><span class="pre">genfromtxt</span></code> which is also able to deal with
missing values. See the documentation of <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html#numpy.loadtxt">loadtxt</a> and <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html#numpy.genfromtxt">genfromtxt</a> for more information.</p>
<p>In numerical simulations, it is often necessary to generate random numbers and if many
of them are needed, it may be efficient to generate an array filled with random numbers.
While NumPy offers many different distributions of random numbers, we concentrate on
equally distributed random numbers in an interval from 0 to 1. An array of a given shape
filled with such random numbers can be obtained as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([[0.76455979, 0.09264023, 0.47090143, 0.81327348, 0.42954314],</span>
<span class="go">       [0.37729755, 0.20315983, 0.62982297, 0.0925838 , 0.37648008]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([[0.23714395, 0.22286043, 0.97736324, 0.19221663, 0.18420108],</span>
<span class="go">       [0.14151036, 0.07817544, 0.4896872 , 0.90010128, 0.21834491]])</span>
</pre></div>
</div>
<p>Clearly, the set of random numbers changes at each call to <code class="docutils literal notranslate"><span class="pre">random.rand</span></code>. Occasionally,
one would like to have reproducible random numbers, for example during unit tests or to
reproduce a particularly interesting scenario in a simulation. Then one can set a seed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123456</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([[0.12696983, 0.96671784, 0.26047601, 0.89723652, 0.37674972],</span>
<span class="go">       [0.33622174, 0.45137647, 0.84025508, 0.12310214, 0.5430262 ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123456</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([[0.12696983, 0.96671784, 0.26047601, 0.89723652, 0.37674972],</span>
<span class="go">       [0.33622174, 0.45137647, 0.84025508, 0.12310214, 0.5430262 ]])</span>
</pre></div>
</div>
<p>Sometimes, it is convenient to graphically represent the matrix elements. <a class="reference internal" href="#mpl-numpy-2"><span class="std std-numref">Figure 4.4</span></a>
shows an example generated by the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">hot</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.image.AxesImage object at 0x7f39027afe48&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="go">&lt;matplotlib.colorbar.Colorbar object at 0x7f39027e58d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Not that the argument <code class="docutils literal notranslate"><span class="pre">interpolation</span></code> of <code class="docutils literal notranslate"><span class="pre">plt.imshow</span></code> is set to <code class="docutils literal notranslate"><span class="pre">'none'</span></code> to ensure
that no interpolation is done which might blur the image.</p>
<figure class="align-center" id="id18">
<span id="mpl-numpy-2"></span><a class="reference internal image-reference" href="_images/mpl_numpy_2.png"><img alt="_images/mpl_numpy_2.png" src="_images/mpl_numpy_2.png" style="width: 20em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.4 </span><span class="caption-text">Graphical representation of an array filled with random numbers.</span><a class="headerlink" href="#id18" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="indexing-arrays">
<span id="id10"></span><h3><span class="section-number">4.2.4. </span>Indexing arrays<a class="headerlink" href="#indexing-arrays" title="Link to this heading">¶</a></h3>
<p>One way of accessing sets of elements of an array makes use of slices which we know
from Python lists. A slice is characterized by a <code class="docutils literal notranslate"><span class="pre">start</span></code> index, a <code class="docutils literal notranslate"><span class="pre">stop</span></code> index
whose corresponding element is excluded, and <code class="docutils literal notranslate"><span class="pre">step</span></code> which indicates the stepsize.
Negative indices are counted from the end of the corresponding array dimension and
a negative value of <code class="docutils literal notranslate"><span class="pre">step</span></code> implies walking in the direction of decreasing indices.</p>
<p>We start by a few examples of slicing for a one-dimensional array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:]</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">array([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([5, 6, 7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([0, 2, 4, 6, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([1, 3, 5, 7, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])</span>
</pre></div>
</div>
<p>The third input, i.e. <code class="docutils literal notranslate"><span class="pre">a[:]</span></code> leaves the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> values open so
that all array elements are returned because by default <code class="docutils literal notranslate"><span class="pre">step</span></code> equals 1. In
the next example, we recall that indices in an array as in a list start at 0.
Therefore, we obtain the second up to the fourth element of the array. In the
fifth input, the second element counted from the end of the array is not part
of the result so that we obtain the numbers from 5 to 7. We could have used
<code class="docutils literal notranslate"><span class="pre">a[5:8]</span></code> instead. In the sixth input, <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> values are again
left open, so that the resulting array starts with 0 but then proceeds in steps
of 2 according to the value of <code class="docutils literal notranslate"><span class="pre">step</span></code> given. In the following example,
<code class="docutils literal notranslate"><span class="pre">start</span></code> is set to 1 and we obtain the elements left out in the previous
example. The last example inverts the sequence of array elements by specifying
a <code class="docutils literal notranslate"><span class="pre">step</span></code> of -1.</p>
<p>The use of <code class="docutils literal notranslate"><span class="pre">a[:]</span></code> deserves a bit more attention. In the case of a list, it
would yield a shallow copy of the original list. For an array, the behavior
is somewhat different. Let us first consider an alias:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(140493158678656, 140493158678656)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([42,  1,  2,  3,  4,  5,  6,  7,  8,  9])</span>
</pre></div>
</div>
<p>In this case, <code class="docutils literal notranslate"><span class="pre">b</span></code> is simply an alias for <code class="docutils literal notranslate"><span class="pre">a</span></code> and refers to the same object.
A modification of elements of <code class="docutils literal notranslate"><span class="pre">b</span></code> will also be visible in <code class="docutils literal notranslate"><span class="pre">a</span></code>. Now, let us
consider a slice comprising all elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(140493155003008, 140493155003168)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([42,  1,  2,  3,  4,  5,  6,  7,  8,  9])</span>
</pre></div>
</div>
<p>Now a new object is generated, but it refers to the same piece of memory. A modification
of elements in <code class="docutils literal notranslate"><span class="pre">b</span></code> will still be visible in <code class="docutils literal notranslate"><span class="pre">a</span></code>. In order to really obtain a copy
of an array, one applies the <code class="docutils literal notranslate"><span class="pre">copy</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([42,  1,  2,  3,  4,  5,  6,  7,  8,  9])</span>
</pre></div>
</div>
<p>It is rather straightforward to extend the concept of slicing to higher
dimensions and we again go through a number of examples to illustrate the
idea. Note that in no case a new array is created in memory so that slicing
is an efficient way of extracting a certain subset of array elements. Our
base array is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27, 28, 29],</span>
<span class="go">       [30, 31, 32, 33, 34, 35]])</span>
</pre></div>
</div>
<p>In view of the two dimensions, we now need two slices separated by a comma,
the first one for the rows and the second one for the columns. The full
array is thus recovered by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,</span> <span class="p">:]</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27, 28, 29],</span>
<span class="go">       [30, 31, 32, 33, 34, 35]])</span>
</pre></div>
</div>
<p>A sub-block can be extracted as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
<span class="go">array([[15, 16, 17],</span>
<span class="go">       [21, 22, 23]])</span>
</pre></div>
</div>
<p>As already mentioned, the first slice pertains to the rows, so that we
choose elements from the third and fourth row. The second slice refers
to columns four to six so that we indeed end up with the output reproduced
above.</p>
<p>Sub-blocks do not need to be contiguous. We can even choose different
values for <code class="docutils literal notranslate"><span class="pre">step</span></code> in different dimensions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[ 0,  3],</span>
<span class="go">       [12, 15],</span>
<span class="go">       [24, 27]])</span>
</pre></div>
</div>
<p>In this example, we have selected every second row and every third column.
If we want to start with the third row, we could write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[12, 15],</span>
<span class="go">       [24, 27]])</span>
</pre></div>
</div>
<p>The following example illustrates a case where only one slice is specified:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">array([[12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23]])</span>
</pre></div>
</div>
<p>The first slice still applies to the row and the missing second slice is replaced
by default by <code class="docutils literal notranslate"><span class="pre">::</span></code> representing all columns.</p>
<p>The interpretation of the last example requires to make connection between the
axis number and its meaning in terms of the array elements. In a two-dimensional
array, the position of the indices follows the convention used in mathematics
as shown in <a class="reference internal" href="#axes"><span class="std std-numref">Figure 4.5</span></a>. This correctness of this interpretation can also
be verified by means of operations which can act along a single axis as is the
case for <code class="docutils literal notranslate"><span class="pre">sum</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 90,  96, 102, 108, 114, 120])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 15,  51,  87, 123, 159, 195])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">630</span>
</pre></div>
</div>
<p>In the first case, the summation is performed along the columns while in the second
case the elements in a given row are added. If no axis is specified, all array
elements are summed.</p>
<figure class="align-center" id="id19">
<span id="axes"></span><a class="reference internal image-reference" href="_images/axes.png"><img alt="_images/axes.png" src="_images/axes.png" style="width: 15em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.5 </span><span class="caption-text">In a two-dimensional array, the first index corresponding to axes 0 denotes
the row while the second index corresponding to axes 1 denotes the column.
This convention is consistent with the one used in mathematics.</span><a class="headerlink" href="#id19" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>We illustrate the generalization to higher dimensions by considering a three-dimensional
array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>

<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
</pre></div>
</div>
<p>Interpreting the array in terms of nested lists, the outer level contains two two-dimensional
arrays along axis 0 as displayed in <a class="reference internal" href="#array3d"><span class="std std-numref">Figure 4.6</span></a>. Within the two-dimensional arrays, the
outer level corresponds to axis 1 and the innermost level corresponds to axis 2.</p>
<figure class="align-center" id="id20">
<span id="array3d"></span><a class="reference internal image-reference" href="_images/array3d.png"><img alt="_images/array3d.png" src="_images/array3d.png" style="width: 15em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.6 </span><span class="caption-text">A three-dimensional array with its three axes.</span><a class="headerlink" href="#id20" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Cutting along the three axes, we obtain the following two-dimensional arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[ 0,  4,  8],</span>
<span class="go">       [12, 16, 20]])</span>
</pre></div>
</div>
<p>These three arrays correspond to the front plane along axis 0, the upper plane along
axis 1 and the left-most plane along axis 2, respectively. In the last example, an
appropriate number of colons can simply be replaced by an ellipsis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[ 0,  4,  8],</span>
<span class="go">       [12, 16, 20]])</span>
</pre></div>
</div>
<p>In order to make the meaning of this notation unique, only one ellipsis is permitted,
but it may appear even between indices like in the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[[[ 0,  1],</span>
<span class="go">         [ 2,  3]],</span>

<span class="go">        [[ 4,  5],</span>
<span class="go">         [ 6,  7]]],</span>


<span class="go">       [[[ 8,  9],</span>
<span class="go">         [10, 11]],</span>

<span class="go">        [[12, 13],</span>
<span class="go">         [14, 15]]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [4, 6]])</span>
</pre></div>
</div>
<p>When selecting a column in a two-dimensional array, one in principle has two
ways to do so. However, they are leading to different results:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([[ 0],</span>
<span class="go">       [ 6],</span>
<span class="go">       [12],</span>
<span class="go">       [18],</span>
<span class="go">       [24],</span>
<span class="go">       [30]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([ 0,  6, 12, 18, 24, 30])</span>
</pre></div>
</div>
<p>In the first case, a two-dimensional array is produced where the second dimension
happens to be of length 1. In the second case, the first column is explicitly selected
and one ends up with a one-dimensional array. This example may lead to the question
whether there is a way to convert a one-dimensional array into a two-dimensional array
containing one column or one row. Such a conversion may be necessary in the context
of broadcasting which we will discuss in <a class="reference internal" href="#broadcasting"><span class="std std-numref">Section 4.2.5</span></a>. The following example
demonstrates how the dimension of an array can be increased by means of a <code class="docutils literal notranslate"><span class="pre">newaxis</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">array([0, 1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="go">array([[0],</span>
<span class="go">       [1],</span>
<span class="go">       [2],</span>
<span class="go">       [3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">array([[0, 1, 2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 4)</span>
</pre></div>
</div>
<p>So far, we have selected subsets of array elements by means of slicing. Another option
is the so-called fancy indexing where elements are specified by lists or arrays of
integers or Booleans for each dimension of the array. Let us consider a few examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27, 28, 29],</span>
<span class="go">       [30, 31, 32, 33, 34, 35]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="go">array([ 1, 15, 11])</span>
</pre></div>
</div>
<p>The lists for axes 0 and 1 combine to yield the index pairs of the elements to be selected.
In our example, these are <code class="docutils literal notranslate"><span class="pre">a[0,</span> <span class="pre">1]</span></code>, <code class="docutils literal notranslate"><span class="pre">a[2,</span> <span class="pre">3]</span></code>, and <code class="docutils literal notranslate"><span class="pre">a[1,</span> <span class="pre">5]</span></code>. As this example shows,
the indices in one list do not need to increase. They rather have be to chosen as a function
of the elements which shall be selected. In this example, there is no way how the two-dimensional
form of the original array can be maintained and we simply obtain a one-dimensional array
containing the three elements selected by the two lists.</p>
<p>A two-dimensional array can be obtained from an originally two-dimensional array if entire
rows or columns are selected like in the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="go">array([[ 0,  3,  5],</span>
<span class="go">       [ 6,  9, 11],</span>
<span class="go">       [12, 15, 17],</span>
<span class="go">       [18, 21, 23],</span>
<span class="go">       [24, 27, 29],</span>
<span class="go">       [30, 33, 35]])</span>
</pre></div>
</div>
<p>Here, we have only specified a list for axis 1 and chosen entire columns. Note that the
chosen columns are not equidistant and thus cannot be obtained by slicing.</p>
<p>Our last example uses fancy indexing with a boolean array. We create an array of random
numbers and want to set all entries smaller than 0.5 to zero. After creating an array
of random numbers from which we construct a Boolean area by comparing with 0.5. The
resulting array is then used not to extract array elements but to set selected array
elements to zero:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">randomarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">randomarray</span>
<span class="go">array([0.48644931, 0.13579493, 0.91986082, 0.38554513, 0.38398479,</span>
<span class="go">       0.61285717, 0.60428045, 0.01715505, 0.44574082, 0.85642709])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indexarray</span> <span class="o">=</span> <span class="n">randomarray</span> <span class="o">&lt;</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indexarray</span>
<span class="go">array([ True,  True, False,  True,  True, False, False,  True,  True,</span>
<span class="go">       False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">randomarray</span><span class="p">[</span><span class="n">indexarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">randomarray</span>
<span class="go">array([0.        , 0.        , 0.91986082, 0.        , 0.        ,</span>
<span class="go">       0.61285717, 0.60428045, 0.        , 0.        , 0.85642709])</span>
</pre></div>
</div>
<p>If instead of setting values below 0.5 to zero, we would have wanted to set them to 0.5,
we could have avoided fancy indexing by using <code class="docutils literal notranslate"><span class="pre">np.clip</span></code>.</p>
<p>As an application of slicing and fancy indexing, we consider a NumPy
implementation of the sieve of Eratosthenes to determine prime numbers. The
principle is illustrated in <a class="reference internal" href="#eratosthenes"><span class="std std-numref">Figure 4.7</span></a> where the steps required
to determine all prime numbers below 50 are depicted. We start out with a list
of integers up to 49. It is convenient to include 0 to be consistent with the
fact that indexing starts at 0 in NumPy. A corresponding array <code class="docutils literal notranslate"><span class="pre">is_prime</span></code> is
initialized with the Boolean value <code class="docutils literal notranslate"><span class="pre">True</span></code>. In each iteration numbers found not
be prime have their value set to <code class="docutils literal notranslate"><span class="pre">False</span></code>. Initially, we mark 0 and 1 as non-primes.</p>
<p>Now we iterate through the array and consider successively each prime number which
we can find. The first one will be 2. Clearly, all multiples of 2 are not prime and
we can cross them out. The next prime is 3, but now we can start crossing out multiples
of 3 at 9. In general, for a prime number <span class="math notranslate nohighlight">\(p\)</span>, we start crossing out multiples
of <span class="math notranslate nohighlight">\(p\)</span> at <span class="math notranslate nohighlight">\(p^2\)</span> because all smaller multiples of <span class="math notranslate nohighlight">\(p\)</span> have been crossed
out before. The maximum number to be considered as candidate is the largest integer
smaller or equal to the maximum integer to be considered. In our example, we consider
integers up to 49 and thus the largest candidate is 7 which happens to be prime.</p>
<figure class="align-center" id="id21">
<span id="eratosthenes"></span><a class="reference internal image-reference" href="_images/eratosthenes.png"><img alt="_images/eratosthenes.png" src="_images/eratosthenes.png" style="width: 40em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.7 </span><span class="caption-text">Iteration steps when the sieve of Eratosthenes is used to determine the prime numbers
below 50. For details see the main text.</span><a class="headerlink" href="#id21" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>This algorithm can be implemented in the following way where we have chosen to
print not only the final result but also the intermediate steps.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="linenos"> 2</span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="n">nmax</span> <span class="o">=</span> <span class="mi">49</span>
<span class="linenos"> 5</span><span class="n">integers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos"> 6</span><span class="n">is_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="linenos"> 7</span><span class="n">is_prime</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
<span class="linenos"> 8</span><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">isqrt</span><span class="p">(</span><span class="n">nmax</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
<span class="linenos"> 9</span>    <span class="k">if</span> <span class="n">is_prime</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
<span class="linenos">10</span>        <span class="n">is_prime</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="p">::</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
<span class="linenos">11</span>    <span class="nb">print</span><span class="p">(</span><span class="n">integers</span><span class="p">[</span><span class="n">is_prime</span><span class="p">])</span>
</pre></div>
</div>
<p>This script produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">7</span>  <span class="mi">9</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">15</span> <span class="mi">17</span> <span class="mi">19</span> <span class="mi">21</span> <span class="mi">23</span> <span class="mi">25</span> <span class="mi">27</span> <span class="mi">29</span> <span class="mi">31</span> <span class="mi">33</span> <span class="mi">35</span> <span class="mi">37</span> <span class="mi">39</span> <span class="mi">41</span> <span class="mi">43</span> <span class="mi">45</span> <span class="mi">47</span> <span class="mi">49</span><span class="p">]</span>
<span class="p">[</span> <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">7</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">17</span> <span class="mi">19</span> <span class="mi">23</span> <span class="mi">25</span> <span class="mi">29</span> <span class="mi">31</span> <span class="mi">35</span> <span class="mi">37</span> <span class="mi">41</span> <span class="mi">43</span> <span class="mi">47</span> <span class="mi">49</span><span class="p">]</span>
<span class="p">[</span> <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">7</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">17</span> <span class="mi">19</span> <span class="mi">23</span> <span class="mi">25</span> <span class="mi">29</span> <span class="mi">31</span> <span class="mi">35</span> <span class="mi">37</span> <span class="mi">41</span> <span class="mi">43</span> <span class="mi">47</span> <span class="mi">49</span><span class="p">]</span>
<span class="p">[</span> <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">7</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">17</span> <span class="mi">19</span> <span class="mi">23</span> <span class="mi">29</span> <span class="mi">31</span> <span class="mi">37</span> <span class="mi">41</span> <span class="mi">43</span> <span class="mi">47</span> <span class="mi">49</span><span class="p">]</span>
<span class="p">[</span> <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">7</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">17</span> <span class="mi">19</span> <span class="mi">23</span> <span class="mi">29</span> <span class="mi">31</span> <span class="mi">37</span> <span class="mi">41</span> <span class="mi">43</span> <span class="mi">47</span> <span class="mi">49</span><span class="p">]</span>
<span class="p">[</span> <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">5</span>  <span class="mi">7</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">17</span> <span class="mi">19</span> <span class="mi">23</span> <span class="mi">29</span> <span class="mi">31</span> <span class="mi">37</span> <span class="mi">41</span> <span class="mi">43</span> <span class="mi">47</span><span class="p">]</span>
</pre></div>
</div>
<p>In line 6 of the Python code, we use <code class="docutils literal notranslate"><span class="pre">np.ones</span></code> with type <code class="docutils literal notranslate"><span class="pre">bool</span></code> to mark all
entries as potential primes. In line 10, slicing is used to mark all multiples
of <code class="docutils literal notranslate"><span class="pre">j</span></code> starting at the square of <code class="docutils literal notranslate"><span class="pre">j</span></code> as non-primes. Finally, in line 11, fancy
indexing is used. The Boolean array <code class="docutils literal notranslate"><span class="pre">is_prime</span></code> indicates through the value <code class="docutils literal notranslate"><span class="pre">True</span></code>
which entries in the array <code class="docutils literal notranslate"><span class="pre">integers</span></code> should be printed.</p>
</section>
<section id="broadcasting">
<span id="id11"></span><h3><span class="section-number">4.2.5. </span>Broadcasting<a class="headerlink" href="#broadcasting" title="Link to this heading">¶</a></h3>
<p>In the previous sections, we have seen examples where an operation involved a
scalar value and an array. This was the case in <a class="reference internal" href="#creating-arrays"><span class="std std-numref">Section 4.2.3</span></a> where
we multiplied an array created by <code class="docutils literal notranslate"><span class="pre">np.ones</span></code> with a number. Another example
appeared in <a class="reference internal" href="#indexing-arrays"><span class="std std-numref">Section 4.2.4</span></a> where in our discussion of fancy indexing
we compared an array with a single number. Even though NumPy behaved in a perfectly
natural way, these examples are special cases of a more general concept, the
so-called broadcasting.</p>
<p>An array can be broadcast to a larger array provided the shapes satisfy certain
conditions. In order to obtain the same dimension as the one of the target
array, dimensions of size 1 are prepended. Then, each component of the shape of
the original array has to be equal to the corresponding component of the shape
of the target array or the component has to equal 1. In <a class="reference internal" href="#broadcast"><span class="std std-numref">Figure 4.8</span></a>, the
target array has shape <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code>. The arrays with shapes <code class="docutils literal notranslate"><span class="pre">(1,)</span></code>, <code class="docutils literal notranslate"><span class="pre">(4,</span> <span class="pre">)</span></code>,
and <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">1)</span></code> satisfy this conditions and can be broadcast as shown in the figure.
In contrast, this is not possible for an array of shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code> as is demonstrated
in the figure. We emphasize the difference between the arrays of shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">1)</span></code>.</p>
<figure class="align-center" id="id22">
<span id="broadcast"></span><a class="reference internal image-reference" href="_images/broadcast.png"><img alt="_images/broadcast.png" src="_images/broadcast.png" style="width: 30em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.8 </span><span class="caption-text">For appropriate shapes, the matrix elements in the highlighted cells can be
broadcast to create the full shape <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code> in this example. An array of
shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code> cannot be broadcast to shape <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code></span><a class="headerlink" href="#id22" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>As the second image in <a class="reference internal" href="#broadcast"><span class="std std-numref">Figure 4.8</span></a> shows, a scalar is broadcast to an
array of the desired shape with all elements being equal. Multiplying an array
with a scalar, we expect that each array element is multiplied by the scalar.
As a consequence, the multiplication of two arrays is carried out element by element.
In other words, a matrix multiplication cannot be done by means of the <code class="docutils literal notranslate"><span class="pre">*</span></code> operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[4, 5],</span>
<span class="go">       [6, 7]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
<span class="go">array([[ 0,  5],</span>
<span class="go">       [12, 21]])</span>
</pre></div>
</div>
<p>The matrix multiplication can be achieved in a number of different ways:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[ 6,  7],</span>
<span class="go">       [26, 31]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[ 6,  7],</span>
<span class="go">       [26, 31]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">@</span> <span class="n">b</span>
<span class="go">array([[ 6,  7],</span>
<span class="go">       [26, 31]])</span>
</pre></div>
</div>
<p>The use of the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operator for the matrix multiplication requires at least
Python 3.5 and NumPy 1.10.</p>
</section>
<section id="universal-functions">
<span id="ufuncs"></span><h3><span class="section-number">4.2.6. </span>Universal functions<a class="headerlink" href="#universal-functions" title="Link to this heading">¶</a></h3>
<p>The mathematical functions provided by the <code class="docutils literal notranslate"><span class="pre">math</span></code> and <code class="docutils literal notranslate"><span class="pre">cmath</span></code> modules from
the Python standard library accept only single real or complex values but no
arrays. For the latter purpose, NumPy and also the scientific library SciPy
offer so-called universal functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([0. , 0.2, 0.4, 0.6, 0.8, 1. , 1.2, 1.4, 1.6, 1.8, 2. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">only size-1 arrays can be converted to Python scalars</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([0.        , 0.19866933, 0.38941834, 0.56464247, 0.71735609,</span>
<span class="go">       0.84147098, 0.93203909, 0.98544973, 0.9995736 , 0.97384763,</span>
<span class="go">       0.90929743])</span>
</pre></div>
</div>
<p>Universal functions can handle multi-dimensional arrays as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0.        , 1.57079633],</span>
<span class="go">       [3.14159265, 4.71238898]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 0.0000000e+00,  1.0000000e+00],</span>
<span class="go">       [ 1.2246468e-16, -1.0000000e+00]])</span>
</pre></div>
</div>
<p>This example shows that the mathematical constant <span class="math notranslate nohighlight">\(\pi\)</span> is not only
available from the <code class="docutils literal notranslate"><span class="pre">math</span></code> and <code class="docutils literal notranslate"><span class="pre">cmath</span></code> modules but also from the NumPy
package. Many of the functions provided by the <code class="docutils literal notranslate"><span class="pre">math</span></code> module are available
as universal functions in NumPy and NumPy offers a few universal functions not
available as normal functions neither in <code class="docutils literal notranslate"><span class="pre">math</span></code> nor in <code class="docutils literal notranslate"><span class="pre">cmath</span></code>. Details
on the functions provided by NumPy are given in the section on <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.math.html">Mathematical functions</a>
in the NumPy reference guide.</p>
<p>While the universal functions in NumPy are mostly restricted to the common
mathematical functions, special functions are available through the SciPy
package.  Often but not always, these functions are implemented as universal
functions as well.  As an example, we create a plot of the Airy function
<span class="math notranslate nohighlight">\(\mathrm{Ai}(x)\)</span> appearing e.g.  in the theory of the rainbow or the
quantum mechanics in a linear potential:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">airy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span><span class="p">,</span> <span class="n">aip</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">bip</span> <span class="o">=</span> <span class="n">airy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Ai(x)&quot;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x7f62184e2278&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">aip</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Ai&#39;(x)&quot;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x7f621bbb4518&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>There exist two types of Airy functions <span class="math notranslate nohighlight">\(\mathrm{Ai}(x)\)</span> and <span class="math notranslate nohighlight">\(\mathrm{Bi}(x)\)</span>
which together with their derivatives are calculated by the <code class="docutils literal notranslate"><span class="pre">airy</span></code> function in one go.
The Airy function <span class="math notranslate nohighlight">\(\mathrm{Ai}(x)\)</span> and its derivative are displayed in <a class="reference internal" href="#airy"><span class="std std-numref">Figure 4.9</span></a>.</p>
<figure class="align-center" id="id23">
<span id="airy"></span><a class="reference internal image-reference" href="_images/airy.png"><img alt="_images/airy.png" src="_images/airy.png" style="width: 20em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.9 </span><span class="caption-text">Airy function <span class="math notranslate nohighlight">\(\mathrm{Ai}(x)\)</span> and its derivative.</span><a class="headerlink" href="#id23" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Occasionally, one needs to create a two-dimensional plot of a function of two variables.
In order to ensure that the resulting array is two-dimensional, the one-dimensional arrays
for the two variables need to run along different axes. A convenient way to do so is the
mesh grid. The function <code class="docutils literal notranslate"><span class="pre">mgrid</span></code> creates two two-dimensional arrays where in one array the
values change along the column while in the other array they change along the rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mf">0.5</span><span class="p">]</span>
<span class="go">array([[[0. , 0. ],</span>
<span class="go">        [0.5, 0.5],</span>
<span class="go">        [1. , 1. ],</span>
<span class="go">        [1.5, 1.5]],</span>

<span class="go">       [[0. , 0.5],</span>
<span class="go">        [0. , 0.5],</span>
<span class="go">        [0. , 0.5],</span>
<span class="go">        [0. , 0.5]]])</span>
</pre></div>
</div>
<p>The slicing syntax corresponds to what we are used from the <code class="docutils literal notranslate"><span class="pre">arange</span></code> function. The equivalence
of the <code class="docutils literal notranslate"><span class="pre">linspace</span></code> function can be obtained by making the third argument imaginary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="n">j</span><span class="p">]</span>
<span class="go">array([[[0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">        [1. , 1. , 1. , 1. , 1. ],</span>
<span class="go">        [2. , 2. , 2. , 2. , 2. ]],</span>

<span class="go">       [[0. , 0.5, 1. , 1.5, 2. ],</span>
<span class="go">        [0. , 0.5, 1. , 1.5, 2. ],</span>
<span class="go">        [0. , 0.5, 1. , 1.5, 2. ]]])</span>
</pre></div>
</div>
<p>A practical application produced by the following code is shown in <a class="reference internal" href="#sinxy"><span class="std std-numref">Figure 4.10</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">))</span>
<span class="go">&lt;matplotlib.image.AxesImage object at 0x7fde9176ea90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id24">
<span id="sinxy"></span><a class="reference internal image-reference" href="_images/sinxy.png"><img alt="_images/sinxy.png" src="_images/sinxy.png" style="width: 20em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.10 </span><span class="caption-text">Application of the mesh grid in a two-dimensional representation of the function
<span class="math notranslate nohighlight">\(\sin(xy)\)</span>.</span><a class="headerlink" href="#id24" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Making use of broadcasting, one can reduce the memory requirement by creating an open mesh grid
instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="n">j</span><span class="p">]</span>
<span class="go">[array([[0.],</span>
<span class="go">       [1.],</span>
<span class="go">       [2.]]), array([[0.  , 0.25, 0.5 , 0.75, 1.  ]])]</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">ogrid</span></code> returns two two-dimensional arrays where one dimension is of length 1.
<a class="reference internal" href="#besselj"><span class="std std-numref">Figure 4.11</span></a> shows an application to Bessel functions obtained by means of the following
code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">jv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nu</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">41</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">jv</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.image.AxesImage object at 0x7fde903736d8&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">)</span>
<span class="go">Text(0.5,0,&#39;$x$&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\nu$&#39;</span><span class="p">)</span>
<span class="go">Text(0,0.5,&#39;$\\nu$&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id25">
<span id="besselj"></span><a class="reference internal image-reference" href="_images/besselj.png"><img alt="_images/besselj.png" src="_images/besselj.png" style="width: 30em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.11 </span><span class="caption-text">Two-dimensional plot of the family of Bessel functions <span class="math notranslate nohighlight">\(J_\nu(x)\)</span> of order <span class="math notranslate nohighlight">\(\nu\)</span>
created by means of an open mesh grid created by <code class="docutils literal notranslate"><span class="pre">ogrid</span></code>.</span><a class="headerlink" href="#id25" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Instead of using the <code class="docutils literal notranslate"><span class="pre">ogrid</span></code> function, one can also construct the argument arrays by hand. In
this case, one has to take care of adding an additional axis in one of the two arrays as in the
following example which results in <a class="reference internal" href="#interference"><span class="std std-numref">Figure 4.12</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">&lt;matplotlib.image.AxesImage object at 0x7fde92509278&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id26">
<span id="interference"></span><a class="reference internal image-reference" href="_images/interference.png"><img alt="_images/interference.png" src="_images/interference.png" style="width: 20em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.12 </span><span class="caption-text">Interference pattern created with argument arrays obtained by means of <code class="docutils literal notranslate"><span class="pre">linspace</span></code> and by
adding an additional axis in one of the two arrays. The function <code class="docutils literal notranslate"><span class="pre">hypot</span></code> determines the
distance of the point given by the two argument coordinates from the origin.</span><a class="headerlink" href="#id26" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>So far, we have considered universal functions mostly as a convenient way to apply a function to
an entire array. However, they can also make a significant contribution to speed up code.
The following script compares the runtime between a for loop evaluating the sine function taken
from the <code class="docutils literal notranslate"><span class="pre">math</span></code> module and a direct evaluation of the sine taken from NumPy for different
array sizes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sin_math</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
    <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">nmax</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xvals</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sin_numpy</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
    <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">nmax</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span>

<span class="n">maxpower</span> <span class="o">=</span> <span class="mi">26</span>
<span class="n">nvals</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxpower</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">tvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span>
<span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nmax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nvals</span><span class="p">):</span>
    <span class="n">tvals</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_math</span><span class="p">(</span><span class="n">nmax</span><span class="p">)</span><span class="o">/</span><span class="n">sin_numpy</span><span class="p">(</span><span class="n">nmax</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="n">usetex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$n_\mathrm</span><span class="si">{max}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$t_\mathrm</span><span class="si">{math}</span><span class="s1">/t_\mathrm</span><span class="si">{numpy}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">nvals</span><span class="p">,</span> <span class="n">tvals</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The results are presented in <a class="reference internal" href="#ufruntime"><span class="std std-numref">Figure 4.13</span></a> and depend on various factors
including the hardware and details of the software environment. The data should
therefore give a rough indication of the speedup and should not be taken too
literally. The first point to note is that even for an array of size 1, NumPy
is faster than the sine function taken from the <code class="docutils literal notranslate"><span class="pre">math</span></code> module. This seems to
contradict our previous result on a scalar argument, but can be explained by
the presence of the for loop in the <code class="docutils literal notranslate"><span class="pre">sin_math</span></code> function which results in an
overhead even if the for loop is strictly speaking unnecessary. Then, for
arrays of an intermediate size, a speed up of roughly a factor of 7 is observed.
Interestingly, for array sizes beyond a few times <span class="math notranslate nohighlight">\(10^4\)</span>, the speed up
reaches values of around 100. This behavior can be explained by the use of the
Anaconda distribution where NumPy is compiled to support Intel’s math kernel
library (MKL). Even without this effect, a speed up between 5 and 10 may be
significant enough to seriously consider the use of universal functions.</p>
<figure class="align-center" id="id27">
<span id="ufruntime"></span><a class="reference internal image-reference" href="_images/uf_runtime.png"><img alt="_images/uf_runtime.png" src="_images/uf_runtime.png" style="width: 20em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.13 </span><span class="caption-text">Runtime comparison between the sine function taken from the <code class="docutils literal notranslate"><span class="pre">math</span></code> module
and from the NumPy package as a function of the array size. Larger values of
the time ratio imply a larger speed up gained by means of NumPy. The data
have been obtained by a version of NumPy with MKL support.</span><a class="headerlink" href="#id27" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="linear-algebra">
<h3><span class="section-number">4.2.7. </span>Linear algebra<a class="headerlink" href="#linear-algebra" title="Link to this heading">¶</a></h3>
<p>Scientific problems which can be formulated in terms of vectors or matrices often
require tools of linear algebra. Therefore, we will discuss a few of the more
important functions NumPy has to offer in that domain. For more details we recommend
to take a look at the <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/routines.linalg.html">documentation of the numpy.linalg module</a>.</p>
<p>As we have discussed earlier, the usual multiplication operator does
element-wise multiplication and uses broadcasting where applicable. The multiplication
of arrays can either be done by means of the <code class="docutils literal notranslate"><span class="pre">dot</span></code> method or the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
<span class="go">array([17, 23])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">@</span> <span class="n">v1</span>
<span class="go">array([17, 23])</span>
</pre></div>
</div>
<p>For the following, we will need to load the <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code> module first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">LA</span>
</pre></div>
</div>
<p>Here we have once more introduced a commonly used abbreviation. A vector can easily
be normalized by means of the <code class="docutils literal notranslate"><span class="pre">norm</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">**</span><span class="mi">2</span>
<span class="go">14.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_normalized</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v_normalized</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Applying the <code class="docutils literal notranslate"><span class="pre">norm</span></code> function to a multi-dimensional array will return the
Frobenius or Hilbert-Schmid norm, i.e. the square root of the sum over the
squares of all matrix elements.</p>
<p>Some of the operations provided by the <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code> module can be applied
to a whole set of arrays. An example is the determinant which mathematically is
defined only for two-dimensional arrays. For a three-dimensional array, determinants
are calculated for each value of the index of axis 0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([[[ 0,  1],</span>
<span class="go">        [ 2,  3]],</span>

<span class="go">       [[ 4,  5],</span>
<span class="go">        [ 6,  7]],</span>

<span class="go">       [[ 8,  9],</span>
<span class="go">        [10, 11]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([-2., -2., -2.])</span>
</pre></div>
</div>
<p>It is also possible to determine the inverse for several matrices at the same time.
Trying to invert a non-invertible matrix will result in a <code class="docutils literal notranslate"><span class="pre">numpy.linalg.linalg.LinAlgError</span></code>
exception.</p>
<p>An inhomogeneous system of linear equations <code class="docutils literal notranslate"><span class="pre">ax=b</span></code> with a matrix <code class="docutils literal notranslate"><span class="pre">a</span></code> and a vector
<code class="docutils literal notranslate"><span class="pre">b</span></code> can in principle be solved by inverting the matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">LA</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([4., 7.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">array([1., 2.])</span>
</pre></div>
</div>
<p>In the last command, we verified that the solution obtained one line above is
indeed correct. Solving inhomogeneous systems of linear equations by inversion
is however not very efficient and NumPy offers an alternative way based on an LU
decomposition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([4., 7.])</span>
</pre></div>
</div>
<p>As we have seen above for the determinant, the function <code class="docutils literal notranslate"><span class="pre">solve</span></code> also allows
to solve several inhomogeneous systems of linear equations in one function
call.</p>
<p>A frequent task in scientific applications is to solve an eigenvalue problem.
The function <code class="docutils literal notranslate"><span class="pre">eig</span></code> determines the right eigenvectors and the associated
eigenvalues for arbitrary square matrices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals</span>
<span class="go">array([ 3.60555128, -3.60555128])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evecs</span>
<span class="go">array([[ 0.75499722, -0.54580557],</span>
<span class="go">       [ 0.65572799,  0.83791185]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">evecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">evecs</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]),</span> <span class="n">evals</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="n">evecs</span><span class="p">[:,</span> <span class="n">n</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">[2.72218119 2.36426089] [2.72218119 2.36426089]</span>
<span class="go">[ 1.96792999 -3.02113415] [ 1.96792999 -3.02113415]</span>
</pre></div>
</div>
<p>In the for loop, we compare the product of matrix and eigenvector with
the corresponding product of eigenvalue and eigenvector and can verify
that the results are indeed correct. In the matrix of eigenvectors, the
eigenvectors are given by the columns.</p>
<p>Occasionally, it is sufficient to know the eigenvalues. In order to reduce
the compute time, one can then replace <code class="docutils literal notranslate"><span class="pre">eig</span></code> by <code class="docutils literal notranslate"><span class="pre">eigvals</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 3.60555128, -3.60555128])</span>
</pre></div>
</div>
<p>In many applications, the matrices appearing in eigenvalue problems are
either symmetric of Hermitian. For these cases, NumPy provides the functions
<code class="docutils literal notranslate"><span class="pre">eigh</span></code> and <code class="docutils literal notranslate"><span class="pre">eigvalsh</span></code>. One advantage is that it suffices to store only
half of the matrix elements. More importantly, these specialized functions are
much faster:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">timeit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">250000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s1">&#39;LA.eig(a)&#39;</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="nb">globals</span><span class="o">=</span><span class="nb">globals</span><span class="p">())</span>
<span class="go">[13.307299479999529, 13.404196323999713, 13.798628489999828]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="s1">&#39;LA.eigh(a)&#39;</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="nb">globals</span><span class="o">=</span><span class="nb">globals</span><span class="p">())</span>
<span class="go">[1.8066274120001253, 1.7375857540000652, 1.739574907000133]</span>
</pre></div>
</div>
<p>In the third line, we have made sure that the initial random matrix is turned
into a symmetric matrix by adding its transpose. In this example, we observe a
speedup of about a factor of 7.</p>
</section>
</section>
<section id="scipy">
<h2><span class="section-number">4.3. </span>SciPy<a class="headerlink" href="#scipy" title="Link to this heading">¶</a></h2>
<p>The functions offered through the SciPy package cover many tasks typically
encountered in the numerical treatment of scientific problems. Here, we can
only give an impression of the potential of SciPy by discussing a few examples.
It is highly recommended to take a look at the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference#api-reference">SciPy API Reference</a>.</p>
<p>As a first example, we consider the linear regression of noisy data. In a first
step, we create data on a line with normally distributed noise added on top:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we can use the <code class="docutils literal notranslate"><span class="pre">linregress</span></code> function from the statistical functions module of SciPy
to do a least-squares regression of the noisy data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">linregress</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">linregress</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">slope</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">intercept</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rvalue</span><span class="p">,</span> <span class="n">stderr</span><span class="p">)</span>
<span class="go">0.9853966954685487 0.0350427823008272</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">rvalue</span></code> refers to the correlation coefficient and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> is the
standard error of the estimated gradient. The graph containing the noisy data
and the linear fit is shown in <a class="reference internal" href="#linregress"><span class="std std-numref">Figure 4.14</span></a>.</p>
<figure class="align-center" id="id28">
<span id="linregress"></span><a class="reference internal image-reference" href="_images/linregress.png"><img alt="_images/linregress.png" src="_images/linregress.png" style="width: 20em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.14 </span><span class="caption-text">Noisy data (blue points) and result of the linear regression (orange line)
obtained by means of <code class="docutils literal notranslate"><span class="pre">scipy.stats.linregress</span></code>.</span><a class="headerlink" href="#id28" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Fitting of data cannot always be reduced to linear regression. Then we can resort
to the <code class="docutils literal notranslate"><span class="pre">curve_fit</span></code> function from the optimization module of SciPy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">curve_fit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">fitfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">fitfunc</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">popt</span>
<span class="go">array([2.08496412, 0.43937489])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>In order to fit to a general function, one needs to provide <code class="docutils literal notranslate"><span class="pre">curve_fit</span></code> with
a function, called <code class="docutils literal notranslate"><span class="pre">fitfunc</span></code> here, which depends on the variable as well as a
set of parameters. In our example, we have chosen two parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span></code> but we are in principle not limited to this number. However, as the
number of parameters increases, the fit tends to become less reliable. The fit
values for the parameters are returned in the array <code class="docutils literal notranslate"><span class="pre">popt</span></code> together with the
covariance matrix for the parameters <code class="docutils literal notranslate"><span class="pre">pcov</span></code>. The outcome of the fit is shown
in <a class="reference internal" href="#curvefit"><span class="std std-numref">Figure 4.15</span></a>.</p>
<figure class="align-center" id="id29">
<span id="curvefit"></span><a class="reference internal image-reference" href="_images/curvefit.png"><img alt="_images/curvefit.png" src="_images/curvefit.png" style="width: 20em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.15 </span><span class="caption-text">Fit of a noisy sine function by means of <code class="docutils literal notranslate"><span class="pre">scipy.optimize.curve_fit</span></code>.</span><a class="headerlink" href="#id29" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Occasionally, a root search is required. As an example, we consider the determination
of the ground state energy in a finite potential well. The eigenvalue condition for a
symmetric eigenstate reads</p>
<div class="math notranslate nohighlight">
\[\sqrt{\epsilon}\cos(\alpha\sqrt{1-\epsilon})-\sqrt{1-\epsilon}\sin(\alpha\sqrt{1-\epsilon})=0\,,\]</div>
<p>where <span class="math notranslate nohighlight">\(\epsilon\)</span> is the energy in units of the well depth and <span class="math notranslate nohighlight">\(\alpha\)</span> is a
measure of the potential strength combining the well depth and its width. One way of
solving this nonlinear equation for <span class="math notranslate nohighlight">\(\epsilon\)</span> is by means of the <code class="docutils literal notranslate"><span class="pre">brentq</span></code> function,
which needs at least the function of which the root should be determined as well as the
bounds of an interval in which the function changes its sign. If the potential well is
sufficiently shallow, i.e. if :math.``alpha`` is sufficiently small, the left-hand side
contains only one root as can be seen from the blue line in <a class="reference internal" href="#brentq"><span class="std std-numref">Figure 4.16</span></a>. In our example,
the function requires an additional argument <span class="math notranslate nohighlight">\(\alpha\)</span> which also needs to be given to
<code class="docutils literal notranslate"><span class="pre">brentq</span></code>. Finally, in order to know how many iterations are need, we set <code class="docutils literal notranslate"><span class="pre">full_output</span></code> to
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">brentq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">sqrt_1me</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">energy</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">sqrt_1me</span><span class="p">)</span>
<span class="gp">... </span>            <span class="o">-</span><span class="n">sqrt_1me</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">sqrt_1me</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">0.45375316586032827</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">       converged: True</span>
<span class="go">           flag: &#39;converged&#39;</span>
<span class="go"> function_calls: 7</span>
<span class="go">     iterations: 6</span>
<span class="go">           root: 0.45375316586032827)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>As the output indicates, the root is found within 6 iterations. The resulting
root is depicted in <a class="reference internal" href="#brentq"><span class="std std-numref">Figure 4.16</span></a> as an orange dot.</p>
<figure class="align-center" id="id30">
<span id="brentq"></span><a class="reference internal image-reference" href="_images/brentq.png"><img alt="_images/brentq.png" src="_images/brentq.png" style="width: 20em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.16 </span><span class="caption-text">Determination of the ground state energy in a finite potential well of depth
<span class="math notranslate nohighlight">\(\alpha=1\)</span> by means of <code class="docutils literal notranslate"><span class="pre">scipy.optimize.brentq</span></code>.</span><a class="headerlink" href="#id30" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Finally, we consider a more complex example which involves optimization and the
solution of a coupled set of differential equations. The physical problem to be
studied numerically is the fall of a chain where the equations of motion are
derived in W. Tomaszweski, P. Pieranski, and J.-C. Geminard, Am. J. Phys. <strong>74</strong>,
776 (2006) <a class="footnote-reference brackets" href="#ajpdoi" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> and account for damping inside the chain. For the initial
configuration of the chain, we take a chain hanging in equilibrium where the
two ends are at equal height and at a given horizontal distance. In the continuum
limit, the chain follows a catenary, but in the discrete case treated here, we
obtain the equilibrium configuration by optimizing the potential energy. This
is done in the method <code class="docutils literal notranslate"><span class="pre">equilibrium</span></code> of our <code class="docutils literal notranslate"><span class="pre">Chain</span></code> class. The method
essentially consists of a call to the <code class="docutils literal notranslate"><span class="pre">minimize</span></code> function taken from the <code class="docutils literal notranslate"><span class="pre">optimize</span></code>
module of SciPy. It optimizes the potential energy defined in the <code class="docutils literal notranslate"><span class="pre">f_energy</span></code> method.
In addition, we have to account for two constraints corresponding to the horizontal
and vertical direction and implemented through the methods <code class="docutils literal notranslate"><span class="pre">x_constraint</span></code> and
<code class="docutils literal notranslate"><span class="pre">y_constraint</span></code>. An example of the result of this optimization procedure is
depicted in <a class="reference internal" href="#hangingchain"><span class="std std-numref">Figure 4.17</span></a> for a chain made of 9 links.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">LA</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">solve_ivp</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Chain</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nlinks</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">damping</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nlinks</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;length requirement cannot be fulfilled with &#39;</span>
                             <span class="s1">&#39;the given number of links&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span> <span class="o">=</span> <span class="n">nlinks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_m</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_a</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">damping</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                          <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                          <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">damping</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">damping</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">damping</span> <span class="o">=</span> <span class="n">damping</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">damping</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">x_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">y_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">f_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">equilibrium</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f_energy</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">),</span>
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span>
                          <span class="n">constraints</span><span class="o">=</span><span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_constraint</span><span class="p">},</span>
                                       <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_constraint</span><span class="p">}])</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">plot_equilibrium</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">phis</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">equilibrium</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">nlinks</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phis</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">nlinks</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phis</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">matrix_m</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span>
        <span class="k">return</span> <span class="n">m</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">vector_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">momenta</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">]</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">:]</span>
        <span class="n">d_angles</span> <span class="o">=</span> <span class="n">momenta</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">-</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">sij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">-</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">mcinv</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">*</span><span class="n">cij</span><span class="p">)</span>
        <span class="n">d_momenta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">*</span><span class="n">sij</span><span class="p">,</span> <span class="n">momenta</span><span class="o">*</span><span class="n">momenta</span><span class="p">)</span>
        <span class="n">d_momenta</span> <span class="o">=</span> <span class="n">d_momenta</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">damping</span><span class="p">,</span> <span class="n">momenta</span><span class="p">)</span>
        <span class="n">d_momenta</span> <span class="o">=</span> <span class="n">d_momenta</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">*</span><span class="n">ci</span>
        <span class="n">d_momenta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mcinv</span><span class="p">,</span> <span class="n">d_momenta</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_momenta</span>
        <span class="n">d</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">:]</span> <span class="o">=</span> <span class="n">d_angles</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">solve_eq_of_motion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_i</span><span class="p">,</span> <span class="n">time_f</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">y0</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equilibrium</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diff</span><span class="p">,</span> <span class="p">(</span><span class="n">time_i</span><span class="p">,</span> <span class="n">time_f</span><span class="p">),</span> <span class="n">y0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Radau&#39;</span><span class="p">,</span>
                                  <span class="n">t_eval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">time_i</span><span class="p">,</span> <span class="n">time_f</span><span class="p">,</span> <span class="n">nt</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">plot_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">phis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="p">:]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phis</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlinks</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phis</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">chain</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mf">0.003</span><span class="p">)</span>
<span class="n">chain</span><span class="o">.</span><span class="n">solve_eq_of_motion</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">chain</span><span class="o">.</span><span class="n">plot_dynamics</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id31">
<span id="hangingchain"></span><a class="reference internal image-reference" href="_images/hanging_chain.png"><img alt="_images/hanging_chain.png" src="_images/hanging_chain.png" style="width: 18em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.17 </span><span class="caption-text">Chain consisting of 9 links hanging in its equilibrium position with a
horizontal distance of the ends equivalent to the length of 7 links.</span><a class="headerlink" href="#id31" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In a second step, the equation of motion for the chain links is solved in the
<code class="docutils literal notranslate"><span class="pre">solve_eq_of_motion</span></code> method by means of <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> taken from the
<code class="docutils literal notranslate"><span class="pre">integrate</span></code> module of SciPy. We need to express the second order equations of
motion in terms of first-order differential equations which can always be
achieved by doubling the number of degrees of freedom by means of auxiliary
variables. The main ingredient then is the function called <code class="docutils literal notranslate"><span class="pre">diff</span></code> in our
example which for a given set of variables returns the time derivatives for
these variables. Furthermore, <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> needs to know the time interval on
which the solution is to be determined together with the time values for which
a solution is requested as well as the initial configuration. Finally, out of
the various solvers, we choose <code class="docutils literal notranslate"><span class="pre">Radau</span></code> which implements an implicit
Runge-Kutta method of Radau IIA family of order 5. <a class="reference internal" href="#fallingchain"><span class="std std-numref">Figure 4.18</span></a>
displays a stroboscopic plot of the chain during is first half period swinging
from the right to the left.</p>
<figure class="align-center" id="id32">
<span id="fallingchain"></span><a class="reference internal image-reference" href="_images/falling_chain.png"><img alt="_images/falling_chain.png" src="_images/falling_chain.png" style="width: 18em;" />
</a>
<figcaption>
<p><span class="caption-number">Figure 4.18 </span><span class="caption-text">Stroboscopic image of a falling chain consisting of 200 elements starting out from
its equilibrium state in the upper right during its first half period swinging to
the left.</span><a class="headerlink" href="#id32" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id13" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>For details see the <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference">NumPy Reference</a>.</p>
</aside>
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>For details see the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference#api-reference">SciPy API Reference</a>.</p>
</aside>
<aside class="footnote brackets" id="matplotlib" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>See the <a class="reference external" href="https://matplotlib.org/gallery/index.html">matplotlib gallery</a> to
obtain an idea of the possibilities offered by matplotlib.</p>
</aside>
<aside class="footnote brackets" id="jupyter" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>For details see the <a class="reference external" href="https://jupyter.org/">homepage of the Jupyter project</a>.</p>
</aside>
<aside class="footnote brackets" id="pandas" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>For details see the <a class="reference external" href="https://pandas.pydata.org/">pandas homepage</a>.</p>
</aside>
<aside class="footnote brackets" id="sympy" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p>For details see the <a class="reference external" href="https://www.sympy.org/">sympy homepage</a>.</p>
</aside>
<aside class="footnote brackets" id="skimage" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p>For details see the <a class="reference external" href="https://scikit-image.org">scikit-image homepage</a>.</p>
</aside>
<aside class="footnote brackets" id="sklearn" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">8</a><span class="fn-bracket">]</span></span>
<p>For details see the <a class="reference external" href="https://https://scikit-learn.org">scikit-learn homepage</a>.</p>
</aside>
<aside class="footnote brackets" id="ajpdoi" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">9</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://doi.org/10.1119/1.2204074">doi:10.1119/1.2204074</a>.</p>
</aside>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="testing.html"><span class="section-number">3. </span>Testing of code</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="profiling.html"><span class="section-number">5. </span>Run-time analysis</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2018—2022, Gert-Ludwig Ingold, license: CC BY 4.0 International.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>